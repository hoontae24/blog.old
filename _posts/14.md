---
title: React 컴포넌트에 ref 전달하기(feat. forwardRef)
# subtitle:
author: Hoontae
date: "2021-08-18"
categories: react
tags: ["react", "frontend"]
background: /img/posts/react/react.jpeg
hidden: false
---

React에서 `ref` `props`가 가장 많이 사용하는 용도는 `DOM` 엘리먼트를 참조하는 경우일 것입니다. HTML 엘리먼트에 대해 `ref`를 `props`로 넘겨주어 `DOM` 엘리먼트를 담거나, 콜백 함수를 넘겨주어 `DOM` 엘리먼트를 매개변수로 접근할 수 있습니다. 하지만 `ref`의 기능은 그것뿐만이 아닙니다.

> Refs provide a way to access DOM nodes or React elements created in the render method.\
> [공식문서(en)](https://reactjs.org/docs/refs-and-the-dom.html) [공식문서(ko)](https://ko.reactjs.org/docs/refs-and-the-dom.html)

리액트 공식문서에서는 ref를 통해 DOM 노드뿐만 아니라 React 엘리먼트(DOM 노드 포함)에 접근할 수 있다고 말합니다. 이번 포스트에서는 React 엘리먼트를 다루는 `ref`에 대해 알아보겠습니다.

---

### DOM 조작을 위한 ref 전달

```js
import { useEffect, useRef } from "react";

function MyInput() {
  return (
    <input />
  )
}

function App() {
  const inputRef = useRef();

  useEffect(() => {
    console.log(inputRef); // { current: <input type="text"> }
  });

  return (
    <div>
      <input ref={inputRef} />
    </div>
  );
}

export default App;
```

기본적으로 `jsx`로 DOM 엘리먼트를 작성할 때 `useRef`로 호출된 값을 `ref` `props`로 넘겨주면 해당 `ref` 객체에 DOM 엘리먼트가 할당됩니다. 만약 `input`을 구현하는 컴포넌트 내부의 DOM 엘리먼트에 접근하려면 어떻게 해야 할까요? 다음 코드처럼 컴포넌트를 작성합니다.

```js
import { useEffect, useRef } from "react";

function MyInput(props) {
  const { ref } = props;

  useEffect(() => {
    console.log("ref:", ref); // undefined
  });

  return <input ref={ref} />;
}

function App() {
  const inputRef = useRef();

  useEffect(() => {
    console.log("inputRef:", inputRef); // { current: undefined }
  });

  return (
    <div>
      <MyInput ref={inputRef} />
    </div>
  );
}

export default App;

```

직접 작성한 `MyInput` 컴포넌트에 `ref` `props`로 ref 객체를 전달했음에도 `MyInput` 컴포넌트 내부에서는 `ref`라는 이름으로 전달된 `props`가 `undefined`로 전달되는 것을 확인할 수 있습니다. 공식문서에서 말하는 것처럼 `ref` 속성은 `DOM 엘리먼트`나 `React Element`를 참조하기 위한 속성이기 때문입니다.([Special Props Warning](https://reactjs.org/warnings/special-props.html))

컴포넌트 내부의 엘리먼트를 참조하기 위해 `props`로 전달하려면 두 가지 쉬운 방법이 있습니다.

#### 1. `ref`가 아닌 `inputRef` 속성으로 전달

`ref`는 컴포넌트 `props` 중에서 일종의 예약어이기 때문에 사용할 수 없습니다. 그래서 다른 이름의 `props`로 전달하면 됩니다.

```js
import { useEffect, useRef } from "react";

function MyInput(props) {
  const { myInputRef } = props;

  useEffect(() => {
    console.log("myInputRef:", myInputRef); // myInputRef: {current: <input type="text">}
  });

  return <input ref={myInputRef} />;
}

function App() {
  const inputRef = useRef();

  useEffect(() => {
    console.log("inputRef:", inputRef); // inputRef: {current: <input type="text">}
    inputRef.current.focus(); // MyInput 컴포넌트의 input 엘리먼트에 focus 됨
  });

  return (
    <div>
      <MyInput myInputRef={inputRef} />
    </div>
  );
}

export default App;
```

컴포넌트에 전달하는 `props`의 이름만 바꾸는 것으로 `ref` 객체를 전달하여 컴포넌트 내부의 엘리먼트에 접근할 수 있습니다. 하지만 이렇게 컴포넌트를 작성하게 되면 `input` 엘리먼트와 거의 비슷한 역할을 `MyInput` 컴포넌트가 수행함에도 약간의 다른 사용법을 제공하는 꼴이 됩니다. 이것은 일관적이지 않게 보일 수 있습니다. (`input` 엘리먼트에 접근하기 위해서 `ref`가 아닌 `inputRef` `props`를 전달해야 함.)

#### 2. forwardRef 사용하기

React에서는 `ref`를 그대로 전달하는 컴포넌트를 작성할 수 있게 도움을 줍니다. 컴포넌트를 `forwardRef`로 감싸주면 됩니다.

```js
import { forwardRef, useEffect, useRef } from "react";

const MyInput = forwardRef(function MyInput(props, forwardedRef) {
  useEffect(() => {
    console.log("forwardedRef:", forwardedRef); // forwardedRef: {current: <input type="text">}
  });

  return <input ref={forwardedRef} />;
});

function App() {
  const inputRef = useRef();

  useEffect(() => {
    console.log("inputRef:", inputRef); // inputRef: {current: <input type="text">}
    inputRef.current.focus(); // MyInput 컴포넌트의 input 엘리먼트에 focus 됨
  });

  return (
    <div>
      <MyInput ref={inputRef} />
    </div>
  );
}

export default App;
```

`forwardRef`함수에 함수형 컴포넌트 형태의 함수를 매개변수로 넣습니다. 이때, 두 번째 인자로 부모에게서 `ref` `props`로 전달된 ref 객체가 전달됩니다.

만약 `MyInput` 컴포넌트가 클래스 컴포넌트로 작성되었다면, 두 방식을 조합하여 `ref`를 전달할 수 있습니다.

```js
import { Component, forwardRef, useEffect, useRef } from "react";

class MyInputWithInputRef extends Component {
  componentDidMount() {
    console.log("myInputRef:", this.props.myInputRef); // myInputRef: {current: <input type="text">}
  }

  render() {
    const { myInputRef } = this.props;
    return <input ref={myInputRef} />;
  }
}

const MyInput = forwardRef(function MyInput(props, forwardedRef) {
  useEffect(() => {
    console.log("forwardedRef:", forwardedRef); // forwardedRef: {current: <input type="text">}
  });

  return <MyInputWithInputRef myInputRef={forwardedRef} />;
});

function App() {
  const inputRef = useRef();

  useEffect(() => {
    console.log("inputRef:", inputRef); // inputRef: {current: <input type="text">}
    inputRef.current.focus(); // MyInput 컴포넌트의 input 엘리먼트에 focus 됨
  });

  return (
    <div>
      <MyInput ref={inputRef} />
    </div>
  );
}

export default App;
```

코드가 길어졌지만 `MyInput`을 사용하는 부분(`App` 컴포넌트)에서는 `MyInput` 컴포넌트가 어떤식으로 구현되어 있는지 알 필요가 없습니다. `<MyInput>`를 `<input>`로 교체하더라도 아무 문제가 없을 것입니다. 이것은 **Input**의 역할을 하는 컴포넌트에 대한 일관성과 신뢰성을 부여하게 됩니다.

---

### React 컴포넌트를 조작하기 위한 ref 전달

`ref` 속성의 React Element를 참조하기 위한 접근 방법입니다. 이번에는 컴포넌트 수준의 React Element에 접근하는 `ref`를 다루어 보겠습니다.

- 클래스 컴포넌트 ref 접근
- useimperativehandle 사용